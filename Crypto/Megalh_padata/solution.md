Άλλο ένα RSA challenge.\
Πρώτο ύποπτο πράγμα μόλις ανοίξουμε το `source.py` είναι η μικρή τιμή του `e = 3`.\
Το public modulus `n` είναι `1024/8 = 128` bytes ενώ το `assert len(FLAG) == 41` στο source σημαίνει ότι $$len(FLAG ^ 3) \approx 3*41 = 123 < 128$$ bytes.\
\
Αυτό σημαίνει ότι το mod στο RSA encryption δε χρησιμοποιείται και βρίσκοντας απλά την τρίτη ρίζα μπορούμε να πάρουμε το αρχικό FLAG. Αυτός είναι και ο λόγος που στο RSA θα έπρεπε να χρησιμοποιείται **padding** ώστε το αρχικό μήνυμα να μην ειναι τόσο μικρό σε σχέση με το public modulus ώστε να συμβαίνει κάτι τέτοιο(επίσης μεγαλύτερο `e` μπορεί να αποτρέψει αυτό το πρόβλημα)./
\
Σε αυτό το challenge, αντί για **padding** έχει χρησιμοποιηθεί **pad** κατά το [One-time pad](https://en.wikipedia.org/wiki/One-time_pad), το οποίο γίνεται XOR με το output του RSA encryption. Βέβαια δεν είναι καν "One-time" μιας και επαναχρησιμοποιείται και για την κρυπτογράφηση ενός άλλου γνωστού σε εμάς μηνύματος(του `b"1337"`).

Έχουμε λοιπόν:
```
m = bytes_to_long(b"1337")
enc = (FLAG^3) XOR pad
c = (m^3) XOR pad
```
Όμως αφού ξέρουμε το `m`, μπορούμε να βρούμε και το `m^3` οπότε και το `pad` κάνοντας `pad = c XOR (m^3)`.
Αφού βρούμε το `pad` γίνεται πάλι με ένα XOR να ανακτήσουμε και το `FLAG^3` και τέλος με μια κυβική ρίζα και το ίδιο το `FLAG`

**ΣΗΜΑΝΤΙΚΟ:** μια έξτρα δυσκολία του challenge είναι να παρατηρήσει κανείς ότι η συνάρτηση που κάνει το xor, αφού εξαντλήσει το μικρότερο από τα δύο ορίσματα, λουπάρει στην αρχη του μέχρι να εξαντλήσει και το μεγαλύτερο από τα δύο. Δηλαδή, εδώ που κάνουμε XOR το `FLAG^3` που έχει μήκος 123 bytes και το `pad` που έχει 128, τα πρώτα 123 bytes του `pad` θα γίνουν XOR 1 προς 1 με τα 123 του `FLAG^3` και τα υπόλοιπα 5 θα γίνουν XOR με τα **πρώτα** 5 bytes του `FLAG^3`. Αυτό σημαίνει ότι αφού κάνουμε `pad XOR enc_flag`, για να βρούμε το σωστό `FLAG^3` πρέπει πάλι να αφαιρέσουμε τα τελευταία 5 bytes.


Solver:
```python
from Crypto.Util.number import long_to_bytes, bytes_to_long
from gmpy2 import iroot

n =  122114072870199297085578020147992814025966594235164531830931259042293000158393859940252405285589996717867934676212957454073503103965727508569537899002931523025520655597503843028746657023947353535021545136547754758633219863823336806019486675282954327452789600129836270965355420808030103480964418043427461870989
enc_flag = "b1511b3fd8cb04b8943512124fabfafd1b350cd63b76dd3d64dfe00dc9148b4c24471c4b2f12f60f7d467a6198f9adedd0d6836ca762d205afd7b6f639bdd9d2967df303f4f7e475189a22dbe73d0e1314fb97e7590f361b2efe9786b5e5931f646bac77717ee83c486bd99634223f482157033e48edfcbf958fa792ec7560e6"
c =  "b7d1cad3d4a45f596a34ff94bb6a775be8e89fe7790fbf7761e231d0210bb41a96f2d3f0384e15fc7c1ccaacfd66855e53200042a9791d732b097009e1cbce206384ca8a94e6ae3892846a954d805bbf02d4fce0a7a41152fb1aa38ed0daec21b7f3ec997a299457e133f31f4163625d166ab8a85298bb6ffe16f5e8e4cf45f2"

def xor(a, b):
    return bytes([a[i % len(a)] ^ b[i % len(b)] for i in range(max(len(a), len(b)))])

m = b"1337"
c_rsa = pow(bytes_to_long(m), 3, n)

otp = xor(long_to_bytes(c_rsa), bytes.fromhex(c))

rsa_flag = xor(bytes.fromhex(enc_flag), otp)[:-5]

m, _ = iroot(bytes_to_long(rsa_flag), 3)
m = long_to_bytes(m)
print(m)

```

