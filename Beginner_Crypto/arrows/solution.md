Το `source.py` αρχείο που δίνεται αποκαλύπτει ότι το flag, αφού του αφαιρέθηκαν τα γνωστά από το flag format prefix και suffix, μετατράπηκε από bytes σε integer. Στη συνέχεια, υποβλήθηκε σε κάποιες bitwise πράξεις: `(n << 2) ^ (n >> 2)`. Δηλαδή πιο συγκεκριμένα σε ένα συνδυασμό από `<<`(bitwise left shift, γεμίζει με 0 τα LSBs), `>>`(bitwise right shift, τα LSBs που shiftάρονται δεξιά χάνονται) και `^`(bitwise XOR).

Για να λύσουμε το challenge, αρκεί να ανακτήσουμε τον αρχικό αριθμό. Έπειτα απλά θα μετατρέψουμε τον αριθμό σε bytes και θα προσθέσουμε το prefix `NH4CK{` και το suffix `}` που μας είναι γνωστά.

Για την ανάκτηση του αριθμού αρκεί να παρατηρήσουμε ότι τα 4 MSBs του αριθμού είναι τα ίδια με αυτα του output. Φαίνεται καλύτερα αν υποθέσουμε ότι ο αριθμός έχει `x` bits:
```
n = <4 πρωτα bits> || <υπόλοποιπα bits>,                                μήκος: x bits
(n << 2) = <4 πρωτα bits> || <υπόλοποιπα bits> || 00,                   μήκος: x + 2 bits
(n >> 2) = <4 πρωτα bits> || <υπόλοποιπα bits εκτός από 2 που έπεσαν>,  μήκος: x - 2 bits
```
Όταν γίνεται το bitwise xor μεταξυ των `(n << 2)` και `(n >> 2)` που έχουν 4 bits διαφορά σε μήκος, είναι σα να βάζουμε 4 μηδενικά στην αρχή του `(n >> 2)` τα οποία δεν αλλάζουν την τιμή του αριθμού και χρειάζονται για να έχουν τα 2 ορίσματα το ίδιο μήκος. Γνωρίζουμε ότι το `a XOR 0 = a` οπότε τα 4 πρώτα bits του output θα είναι τα 4 πρώτα bits του `(n << 2)` δηλαδή τα 4 πρώτα bits του ίδιου του `n`! 

Στη συνέχεια, για να πάρουμε και τα υπόλοιπα bits αρκεί να παρατηρήσουμε ότι τα **επόμενα** 4 bits του output είναι τα `<δεύτερα 4 bits> XOR <πρώτα 4 bits>`, αφού όμως έχουμε ανακτήσει τα πρώτα 4 bits μπορούμε κάνοντας ένα απλό XOR να πάρουμε και τη 2η τετράδα από bits.

Επαναλαμβάνουμε αυτή τη διαδικασία, κάθε φορά χρησιμοποιούμε τα πιο πρόσφατα 4 bits που βρήκαμε για να μάθουμε τα επόμενα 4.

Δύο σημεία που χρειάζονται προσοχή: 
- Λόγω των shifts, θα πρεπει να σταματήσουμε τη λούπα μας όταν έχουν μείνει 2 bits και 
- Πιθανώς τα πρώτα 4 bits **αρχίζουν με μηδενικά**. Αυτό σημαίνει ότι για να ανακτήσουμε σωστά τα bits πρέπει να βάλουμε αυτά τα μηδενικά χειροκίνητα και όχι να βασιστούμε στη συνάρτηση `bin()` της python που γυρνάει τον αριθμό σε δυαδική αναπαράσταση κόβοντας όλα τα leading 0s. Ευτυχώς, λόγω των shifts και επειδή κάθε byte έχει 8 bits και ο αριθμός μας προέκυψε από bytes ξέρουμε ότι το μήκος όλων των bits θα είναι 2 συν κάποιο πολλαπλάσιο του 8. Άρα μπορούμε να βρούμε ακριβώς πόσα μηδενικά να βάλουμε στην αρχή.
Solver:
```python
from Crypto.Util.number import long_to_bytes

out = 28159761705955253718454662360068272342440885298700051112417729041843661663258713442591709941031131886387
out = bin(out)[2:]
out = ((2 - len(out)) % 8)*'0' + out
flag = out[:4]
out = out[4:]
while len(out) >= 4:
    flag += "{0:04b}".format(int(flag[-4:], 2) ^ int(out[:4], 2))
    out = out[4:]
print("NH4CK{" + long_to_bytes(int(flag, 2)).decode() + "}")

```

