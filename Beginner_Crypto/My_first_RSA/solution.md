Ανοίγοντας το αρχείο `source.py` βλέπουμε ότι πρόκειται για ένα crypto challenge σχετικό με το κρυπτοσύστημα [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).
Έχουμε δύο public moduli `n`, `t`, με `n = p * q` και `t = q * r`(`p`, `q`, `r`, άγνωστοι) και το κρυπτογραφημένο με δημόσιο κλειδί `(n, 65537)` flag `c`. 
Γνωρίζουμε πως το RSA βασίζεται στο πρόβλημα παραγοντοποίησης μεγάλων αριθμών. Αν μπορούσαμε να παραγοντοποιήσουμε το `n`, θα ήταν εφικτό στη συνέχεια να ανακτήσουμε το ιδιωτικό κλειδί `d` και να αποκρυπτογραφήσουμε το flag ακρίβως όπως θα έκανε ο "νόμιμος" κάτοχος του ιδιωτικού κλειδιού.

Εδώ το vulnerability είναι ότι τα `n`, `t` έχουν ένα κοινό παράγοντα, μπορούμε λοιπόν με μια αποδοτική υλοποίηση του αλγορίθμου για έυρεση Μέγιστου Κοινού Διαιρέτη να βρούμε τον κοινό παράγοντα `q`, και στη συνέχεια με μια απλή διαίρεση `n//q`(το διπλό `//` είναι για ακέραια διαίρεση και όχι απλή διαίρεση που θα έχανε πολυ precision) να βρούμε και το `p`. Χρησιμοποιήσαμε την built-in μεθοδο για ΜΚΔ που έχει η pycryptodome.

Solver:
```python
from Crypto.Util.number import long_to_bytes, GCD

n = 128411446334574397182142177367036816747607516557946946475777213551854067644685228101846545351752528860053256201850680187014971373044213635458190035990313191878520145167897288451782716761583016211762230468690449552804140075391312689609630750165756863665938534272916291227872195163415073812595741859662165354831
t = 141505967486528781564932679320413187614608294542911182129277069597881744783352153182505684610363516263367917974683137645452946523412426253562685737300010982964119710055690077472513018470085598474788781104349985350519719483767063218168224886811895107705693040433237523708021630333573401381616728939166227840173
c = 47368297919355917559659743122199717890317581926005050220000916785173383662302111085256205262902138895003372667000048007521903028535241417463243887214578276537563140434870614356970685905632656683371052807455061227049476144862077015488389346383789227869074009272376016873578082687346959237300641158542093471434

p = GCD(n, t)
q = n//p
# then proceed with standard methodology to find d, same way the party that performs the key generation would do it
phi = (p - 1) * (q - 1)
d = pow(65537, -1, phi)
print(long_to_bytes(pow(c, d, n))) # RSA decryption is c^d % n
```

